
# Data Pre-processing

Before modelling with the PREDICTS data, there are a few basic pre-processing steps that must be carried out. First, for the `r round((as.integer(summary(predicts$Measurement==predicts$Effort_corrected_measurement)['FALSE'][[1]])/nrow(predicts))*100,1)`% of records that are of an effort-sensitive metric, and where sampling effort differs among sampled sites within the study, we need to correct sampling effort. This is done by rescaling sampling effort within each study, such that the most-sampled site gets a relative effort value of 1, and the sampling effort for all other sites is scaled linearly relative to this maximum value. The _CorrectSamplingEffort_ function in the _predictsFunctions_ package carries out these operations:

```{r,echo=TRUE,results=TRUE}
# Correct effort-sensitive abundance measures (assumes linear relationship between effort and recorded abundance)
predicts <- predictsFunctions::CorrectSamplingEffort(diversity = predicts)
```

Next, some samples in PREDICTS were entered such that a sampled 'Site' consisted of very finely divided samples. For example, samples may have been entered as individual traps. This is not in keeping with the strict definition of a 'Site' in the PREDICTS database. To get around this issue, we combine sites with identical coordinates, belonging to the same study and spatial block of sites, sampled on the same dates, sampled with the same methods and recorded using the same diversity metric, and situated within the same land-use type and human land-use intensity. This merging of sites is carried out by the _MergeSites_ function in the _predictsFunctions_ package (warning, this operation can take a few minutes to run, so you might want to go and make a cup of tea!):

```{r,echo=TRUE,results=TRUE}
predicts <- predictsFunctions::MergeSites(diversity = predicts,silent = TRUE)
```

There are two main ways that you can now analyze the PREDICTS data:

1. Using the raw species-level data, modelling the presence/absence or abundance of individual species; or
2. Using site-level biodiversity summaries, such as species richness, total community abundance or other aggregate biodiversity measures

We are now ready to build some simple models using the PREDICTS database. For the modelling, we will use my _StatisticalModels_ package, and we will use the _DHARMa_ package for model diagnostics:

```{r,echo=TRUE,results=TRUE,message=FALSE,warning=FALSE}
library(StatisticalModels)
library(DHARMa)
```

# Basic Species-level Models

One way we can use the PREDICTS data is to build models based on the raw data for individual species. 

So that the models run in a reasonably short amount of time, we will focus here on data for reptiles:

```{r,echo=TRUE,results=TRUE}
reptiles <- droplevels(predicts[(predicts$Class=="Reptilia"),])
```

We will create a variable called "*Occur*" that represents the presence or absence of reptile species:

```{r,echo=TRUE,results=TRUE}
# First, make sure that all records are of abundance or occurrence
reptiles <- reptiles[(reptiles$Diversity_metric_type %in% c("Abundance","Occurrence")),]

# Now, create the occurrence variable, where all values > 0 are treated as
# presence records
reptiles$Occur <- ifelse(reptiles$Measurement>0,1,0)
```

Before we build a model, we need to rearrange the land-use classification a bit. Any sites where the land-use type was entered as 'Cannot decide' need to be set as NA values. We will also group together secondary vegetation sites at all stages of recovery, since there are a relatively limited number of sites for reptiles.

```{r,echo=TRUE,results=TRUE}
reptiles$LandUse <- dplyr::recode(reptiles$Predominant_land_use,
                                 'Primary vegetation' = 'Primary',
                                 'Young secondary vegetation' = 'Secondary',
                                 'Intermediate secondary vegetation' = 'Secondary',
                                 'Mature secondary vegetation' = 'Secondary',
                                 'Secondary vegetation (indeterminate age)' = "Secondary",
                                 'Plantation forest' = 'Plantation',
                                 'Cropland' = 'Cropland',
                                 'Pasture' = 'Pasture',
                                 'Urban' = 'Urban',
                                 'Cannot decide' = NA_character_)
```

Let's try a very simple model fitting just land use. We will also build a null model for comparison.

```{r,echo=TRUE,results=TRUE}
occMod1 <- StatisticalModels::GLMER(modelData = reptiles,responseVar = "Occur",
                               fitFamily = "binomial",fixedStruct = "LandUse",
                               randomStruct = "(1|SS)+(1|SSB)+(1|SSBS)+(1|Taxon_name_entered)",
                               saveVars = c("Longitude","Latitude"))

# To compare the models, they need to be fit to the same dataset
# Therefore, we first need to drop records with unknown land-use type
reptiles.with.lu <- reptiles[(!is.na(reptiles$LandUse)),]

occModNull <- StatisticalModels::GLMER(modelData = reptiles.with.lu,responseVar = "Occur",
                                  fitFamily = "binomial",fixedStruct = "1",
                                  randomStruct = "(1|SS)+(1|SSB)+(1|SSBS)+(1|Taxon_name_entered)",
                                  saveVars = c("Longitude","Latitude"))

print.LM(occMod1)

summary.LM(occMod1)

AIC(occMod1$model,occModNull$model)

anova(occMod1$model,occModNull$model)
```

If we look at the pseudo R<sup>2</sup> values of the model, we can see that the random effects explain most of the variation in reptile species presence/absence, while land use explains `r round(StatisticalModels::R2GLMER(occMod1$model)$marginal*100,1)`%.

```{r,echo=TRUE,results=TRUE}
StatisticalModels::R2GLMER(occMod1$model)
```

Plotting this model shows significant declines in the probability of occurrence of reptile species in secondary vegetation, plantation forests and pastures.

```{r,echo=TRUE,results=TRUE}
PlotGLMERFactor(model = occMod1$model,data = occMod1$data,responseVar = "Prob. occurrence",logLink = "b",catEffects = "LandUse")
```

# Basic Assemblage-Level Models

To use the site-level approach, you need to use the _SiteMetrics_ function to create a site-level data-frame. You can use the _extra.cols_ argument to include non-standard columns from the original PREDICTS database into the site-level data-frame. For now, we will save the land-use type, the block and site-within-block unique identifiers, *SSB* and *SSBS* (which aren't saved by default, and will be important in the modelling), and the Longitude and Latitude fields (as you will see, these will come in handy later for model checking):

```{r,echo=TRUE,results=TRUE}
sites <- predictsFunctions::SiteMetrics(diversity = predicts,
                                           extra.cols = c("Longitude","Latitude",
                                                          "Predominant_land_use",
                                                          "SSB","SSBS"),
                                           srEstimators = NULL)
```

As when we ran the species-level models, we need to rearrange the land-use classification. This time we have a lot of data available, so we will treat the secondary vegetation classes separately:

```{r,echo=TRUE,results=TRUE}
sites$LandUse <- dplyr::recode(sites$Predominant_land_use,
                               'Primary vegetation'='Primary',
                               'Mature secondary vegetation'='Secondary_Mature',
                               'Intermediate secondary vegetation'='Secondary_Intermediate',
                               'Young secondary vegetation'='Secondary_Young',
                               'Plantation forest'='Plantation',
                               'Cropland'='Cropland',
                               'Pasture'='Pasture',
                               'Urban'='Urban',
                               'Secondary vegetation (indeterminate age)'=NA_character_,
                               'Cannot decide'=NA_character_)
```

We will start by running a very simple model of species richness as a function just of land use.

```{r,echo=TRUE,results=TRUE}
richMod1 <- StatisticalModels::GLMER(modelData = sites,
                                     responseVar = "Species_richness",
                                     fitFamily = "poisson",
                                     fixedStruct = "LandUse",
                                     randomStruct = "(1|SS)+(1|SSB)",
                                     saveVars = c("Longitude","Latitude"))
```

If our species richness estimates conform to a true Poisson distribution, then the mean and variance of the values should be equal. Ecological count data are often over-dispersed, whereby the variance of the values is much greater than the mean. This seems very likely to be the case here:

```{r,echo=TRUE,results=TRUE}
mean(sites$Species_richness)
var(sites$Species_richness)
```

We can use the _GLMEROverdispersion_ function to test the model, revealing substantial over-dispersion:

```{r,echo=TRUE,results=TRUE}
StatisticalModels::GLMEROverdispersion(model = richMod1$model)
```

One way to deal with the issue of over-dispersion in Poisson mixed-effects models is to include an observation-level random effect (i.e., a random effect with one group per data point). Here, this mean fitting site identity as a random effect:

```{r,echo=TRUE,results=TRUE}
richMod2 <- StatisticalModels::GLMER(modelData = sites,
                                     responseVar = "Species_richness",
                                     fitFamily = "poisson",
                                     fixedStruct = "LandUse",
                                     randomStruct = "(1|SS)+(1|SSB)+(1|SSBS)",
                                     saveVars = c("Longitude","Latitude"))

print.LM(richMod2)

summary.LM(richMod2)
```

Testing for over-dispersion in the new model shows that we have dealt with the issue successfully:

```{r,echo=TRUE,results=TRUE}
StatisticalModels::GLMEROverdispersion(model = richMod2$model)
```

Now that we have settled on a random-effects structure, we will create a null, intercept-only model with which to compare our model of the effect of land use:

```{r,echo=TRUE,results=TRUE}
# To compare the models, they need to be fit to the same dataset
# Therefore, we first need to drop records with unknown land-use type
sites.with.lu <- sites[!is.na(sites$LandUse),]

richModNull <- StatisticalModels::GLMER(modelData = sites.with.lu,
                                     responseVar = "Species_richness",
                                     fitFamily = "poisson",
                                     fixedStruct = "1",
                                     randomStruct = "(1|SS)+(1|SSB)+(1|SSBS)",
                                     saveVars = c("Longitude","Latitude"))

```

Comparing the land-use and null models shows that land use has a strong association with species richness at the PREDICTS sites:

```{r,echo=TRUE,results=TRUE}

AIC(richMod2$model,richModNull$model)

anova(richMod2$model,richModNull$model)
```

Calculating the pseudo-R<sup>2</sup> values for the land-use model shows that land use alone only explains `r round((R2GLMER(richMod2$model)$marginal)*100,1)`% of the variation in species richness, but that is unsurprising in such a heterogeneous database.

```{r,echo=TRUE,results=TRUE}
R2GLMER(richMod2$model)
```

Plotting the modelled effects of land use on species richness shows a substantial reduction in species richness in more disturbed land uses:

```{r,echo=TRUE,results=TRUE}
PlotGLMERFactor(model = richMod2$model,data = richMod2$data,
                responseVar = "Species richness",logLink = "e",
                catEffects = "LandUse",xtext.srt = 45,
                order = c(1,4,3,2,5,7,6,8),
                params = list(mar = c(1.2, 3.5, 0.2, 0.2)))
```

With any analysis of spatial data, there is the possibility for spatial autocorrelation, meaning that data points cannot be assumed to be independent. Because of the hierarchical structure of the PREDICTS analyses, we tend to investigate spatial autocorrelation in the residuals associated with individual ***Studies*** in the original dataset. This can be done using the *SpatialAutocorrelationTest* function:

```{r,echo=TRUE,results=TRUE,fig.cap="Distribution of P values from a series of tests for spatial autocorrelation in the residuals associated with underlying ***Study***. P values < 0.05 indicate significant spatial autocorrelation"}
sat <- StatisticalModels::SpatialAutocorrelationTest(richMod2,ranefGrouping = "SS")

hist(sat$P,breaks=c(0,0.05,0.1,0.2,0.3,0.4,0.5,0.6,0.7,0.8,0.9,1),freq=FALSE)
abline(v=0.05,lwd=2,col="#ff0000")
```

By chance, we would expect to see significant spatial autocorrelation in 5% of cases. Here the residuals associated with `r round((length(which(sat$P<0.05))/length(which(!is.na(sat$P))))*100,1)`% of studies return a significant spatial autocorrelation test.

# References